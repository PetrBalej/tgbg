#' @title Generate bias raster (Kernel Smoothed Intensity of Point Pattern, density.ppp) and/or corresponding background points
#'
#' @param p sf/sfc (POINT/MULTIPOINT): Points
#' @param r RasterLayer: Template raster
#' @param n integer or numeric: Ratio (< 1) or int to sample.
#' @param sigma numeric vector: \code{density.ppp} \emph{sigma} parameter, multiplies \emph{r} pixel size \emph{x} and/or \emph{y} resolution (for isotropic or anisotropic kernel)
#' @param output character vector: \emph{br} (bias raster) and/or \emph{bg} (corresponding background points generated by \code{tgbg::sample})
#' @param crs integer: Force crs.
#'
#' @return List: \emph{br}: RasterLayer (bias raster); \emph{bg}: sf (POINT/MULTIPOINT) (background points) with nested List of choosen \emph{sigma} levels

bg <- function(p, r, n = 0.1, sigma = c(0.1, 0.5, 1, 2, 3, 4), output = c("br", "bg"), crs = NA, anisotropic = FALSE) {
    out <- list("br" = NA, "bg" = NA)

    if (!is(r, "RasterLayer")) {
        stop("r: only RasterLayer allowed!")
        return(out)
    }

    if (is(p, "sf") && sf::st_geometry_type(rp, by_geometry = FALSE) == "POINT") {
        stop("p: only sf/sfc (POINT/MULTIPOINT) allowed!")
        return(out)
    }

    if (is.integer(crs)) {
        sf::st_crs(p) <- paste0("epsg:", crs)
        sf::st_crs(r) <- paste0("epsg:", crs)
    } else {
        if (sf::st_crs(p)$proj4string == sf::st_crs(r)$proj4string) {
            stop("p and r crs are not equal!")
            return(out)
        }
        crs <- raster::crs(r)
    }

    ext <- raster::extent(r)
    ow <- owin(xrange = c(ext@xmin, ext@xmax), yrange = c(ext@ymin, ext@ymax))

    p.coords <- sf::st_coordinates(p)
    p.coords.ppp <- ppp(p.coords[, 1], p.coords[, 2], window = ow)

    bg <- list()
    br <- list()

    # sq2rad <- c((1 / 6) / 4, 0.1 / 4) # LSD 2rad
    ress <- raster::res(r)

    sigma.df <- as.data.frame(cbind("adj_i" = sigma, "x" = ress[1] * sigma, "y" = ress[2] * sigma))

    for (adj in sigma) {
        fa <- as.vector(unlist(sigma.df %>% filter(adj_i == adj) %>% dplyr::select(x, y)))

        if (anisotropic) {
            # varcov: enable anisotropic smoothing kernel to correctly set geographic (lat/lon) coordinates x and y dimensions if tepmlate raster has different xy resolution of pixel
            d <- density.ppp(p.coords.ppp, varcov = diag(fa^2))
        } else {
            # sigma: isotropic kernel for projected crs (xy dimensions are equal)
            d <- density.ppp(p.coords.ppp, sigma = fa[1])
        }

        br.temp <- raster::resample(raster::raster(d), r, method = "bilinear")

        raster::crs(br.temp) <- crs
        br.temp <- raster::mask(raster::crop(br.temp, raster::extent(r)), r)
        br.temp <- raster::setMinMax(br.temp)

        # normalize to 0-1
        r.min <- raster::minValue(br.temp)
        r.max <- raster::maxValue(br.temp)
        br.temp <- ((br.temp - r.min) / (r.max - r.min))
        br.temp <- raster::setMinMax(br.temp)

        br[[as.character(adj)]] <- NA
        if (is.element("br", output)) {
            br[[as.character(adj)]] <- br.temp
        }

        bg[[as.character(adj)]] <- NA
        if (is.element("bg", output)) {
            bg[[as.character(adj)]] <- tgbg::sample(br.temp, n, prob = TRUE, crs = crs)
        }
    }

    return(list("bg" = bg, "br" = br))
}